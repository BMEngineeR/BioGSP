---
title: "BioGSP: Spectral Graph Wavelet Transform for Spatial Data (New Workflow)"
author: "BioGSP Package"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    theme: flatly
vignette: >
  %\VignetteIndexEntry{BioGSP: Spectral Graph Wavelet Transform for Spatial Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      fig.width = 10, fig.height = 6)
```

# Introduction

BioGSP provides **Spectral Graph Wavelet Transform (SGWT)** analysis for spatial biological data. This package enables multi-scale analysis of spatial patterns using graph signal processing techniques.

**NEW in Version 2.0+**: Complete workflow restructure with object-oriented design!

## Key Capabilities

- **Object-oriented SGWT workflow** with clear separation of concerns
- **Multi-scale spatial analysis** using spectral graph wavelets
- **Flexible data input** with custom column naming
- **Energy-normalized similarity analysis** with comprehensive metrics
- **Multiple wavelet kernels** (Mexican Hat, Meyer, Heat)
- **Comprehensive visualization** tools
- **Detailed inverse transform results** (low-pass, band-pass approximations)

## New Workflow Overview

The new workflow consists of four main steps:

1. **`initSGWT()`**: Initialize SGWT object with data and parameters
2. **`runSpecGraph()`**: Build spectral graph structure
3. **`runSGWT()`**: Perform forward and inverse SGWT transforms
4. **`runSGCC()`**: Calculate energy-normalized weighted similarity

# Setup

```{r load-libraries}
# Load required packages
library(ggplot2)
library(patchwork)
library(viridis)
library(Matrix)
library(igraph)
library(RANN)
library(RSpectra)

# Load BioGSP functions
source('../R/simulation.R')
source('../R/sgwt_core.R')
source('../R/sgwt_main.R')
source('../R/utilities.R')
source('../R/visualization.R')

# Set random seed for reproducibility
set.seed(123)
```

# New SGWT Workflow Demonstration

## Generate Example Pattern

```{r generate-pattern}
# Create a spatial pattern with concentric circles
demo_pattern <- simulate_multiscale(
  grid_size = 40,        # Moderate size for fast computation
  n_centers = 1,         # Single center pattern
  Ra_seq = 5,            # Inner circle radius
  Rb_seq = 10,           # Outer ring radius
  seed = 123
)[[1]]

# Display pattern structure
cat("Generated pattern dimensions:", nrow(demo_pattern), "x", ncol(demo_pattern), "\n")
cat("Column names:", paste(colnames(demo_pattern), collapse = ", "), "\n")
cat("Signals available:", sum(demo_pattern$signal_1), "inner pixels,", sum(demo_pattern$signal_2), "outer pixels\n")
```

## Visualize Input Pattern

```{r visualize-pattern, fig.width=10, fig.height=4}
# Create visualizations for both signals
p1 <- ggplot(demo_pattern, aes(X, Y, fill = factor(signal_1))) +
  geom_tile() +
  scale_fill_manual(values = c("0" = "white", "1" = "#e31a1c"), 
                    name = "Signal", labels = c("Background", "Inner Circle")) +
  coord_fixed() + theme_void() + ggtitle("Signal 1: Inner Circles")

p2 <- ggplot(demo_pattern, aes(X, Y, fill = factor(signal_2))) +
  geom_tile() +
  scale_fill_manual(values = c("0" = "white", "1" = "#1f78b4"), 
                    name = "Signal", labels = c("Background", "Outer Ring")) +
  coord_fixed() + theme_void() + ggtitle("Signal 2: Outer Rings")

print(p1 + p2)
```

## Step 1: Initialize SGWT Object

```{r init-sgwt}
# Initialize SGWT object with custom column names
SG <- initSGWT(
  data.in = demo_pattern,
  x_col = "X",           # Custom X coordinate column name
  y_col = "Y",           # Custom Y coordinate column name
  signals = c("signal_1", "signal_2"),  # Analyze both signals
  k = 12,                # Number of nearest neighbors
  J = 4,                 # Number of wavelet scales
  scaling_factor = 2,    # Scale progression factor
  kernel_type = "heat"
)

# Display initialized object
print(SG)
```

## Step 2: Build Spectral Graph

```{r build-graph}
# Build spectral graph structure
SG <- runSpecGraph(SG, verbose = TRUE)

# Check updated object
cat("Graph construction completed!\n")
cat("Adjacency matrix dimensions:", dim(SG$Graph$adjacency_matrix), "\n")
cat("Number of eigenvalues computed:", length(SG$Graph$eigenvalues), "\n")
```

## Step 3: Run SGWT Analysis

```{r run-sgwt}
# Perform SGWT forward and inverse transforms
SG <- runSGWT(SG, verbose = TRUE)

# Display final object with all results
print(SG)
```

## Visualize SGWT Decomposition

```{r plot-decomposition, fig.width=12, fig.height=8}
# Plot SGWT decomposition results for signal_1
if (requireNamespace("ggpubr", quietly = TRUE)) {
  decomp_plots <- plot_sgwt_decomposition(
    SG = SG,
    signal_name = "signal_1",
    plot_scales = 1:3,     # Show first 3 scales
    ncol = 3
  )
  
  print(decomp_plots)
} else {
  cat("Install 'ggpubr' package for visualization\n")
}
```

## Energy Analysis

```{r energy-analysis}
# Analyze energy distribution across scales for signal_1
energy_analysis <- sgwt_energy_analysis(SG, "signal_1")
print(energy_analysis)

# Create energy distribution plot
energy_plot <- ggplot(energy_analysis, aes(x = scale, y = energy_ratio)) +
  geom_bar(stat = "identity", fill = "steelblue", alpha = 0.7) +
  geom_text(aes(label = paste0(round(energy_ratio * 100, 1), "%")), 
            vjust = -0.5, size = 3) +
  labs(title = "Energy Distribution Across SGWT Scales (Signal 1)",
       x = "Scale", y = "Energy Ratio") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(energy_plot)
```

# Advanced Features Demonstration

## Different Wavelet Kernels

```{r kernel-comparison}
# Compare different kernel types
kernels <- c("mexican_hat", "meyer", "heat")
kernel_results <- list()

for (kernel in kernels) {
  # Initialize with different kernel
  SG_temp <- initSGWT(
    data.in = demo_pattern,
    x_col = "X", y_col = "Y",
    signals = "signal_1",
    k = 12, J = 3,           # Reduced for faster computation
    kernel_type = kernel
  )
  
  # Run full workflow
  SG_temp <- runSpecGraph(SG_temp, verbose = FALSE)
  SG_temp <- runSGWT(SG_temp, verbose = FALSE)
  
  kernel_results[[kernel]] <- SG_temp
}

# Compare reconstruction errors
comparison_df <- data.frame(
  Kernel = kernels,
  RMSE = sapply(kernel_results, function(x) x$Inverse$signal_1$reconstruction_error),
  stringsAsFactors = FALSE
)

print("Kernel Performance Comparison:")
print(comparison_df)

# Plot comparison
ggplot(comparison_df, aes(x = Kernel, y = RMSE, fill = Kernel)) +
  geom_bar(stat = "identity", alpha = 0.7) +
  geom_text(aes(label = round(RMSE, 6)), vjust = -0.5) +
  scale_fill_viridis_d() +
  labs(title = "SGWT Reconstruction Error by Kernel Type",
       x = "Kernel Type", y = "RMSE") +
  theme_minimal()
```

## Step 4: Pattern Similarity Analysis

```{r similarity-analysis}
# Calculate similarity between signal_1 and signal_2 in same object
similarity_within <- runSGCC("signal_1", "signal_2", SG = SG, return_parts = TRUE)

cat("Pattern Similarity Analysis (within same graph):\n")
cat(sprintf("Overall similarity: %.4f\n", similarity_within$S))
cat(sprintf("Low-frequency similarity: %.4f\n", similarity_within$c_low))
cat(sprintf("Non-low-frequency similarity: %.4f\n", similarity_within$c_nonlow))
cat(sprintf("Energy weights - Low: %.3f, Non-low: %.3f\n", 
           similarity_within$w_low, similarity_within$w_NL))

# Generate a second pattern for cross-comparison
pattern_2 <- simulate_multiscale(
  grid_size = 40,
  n_centers = 1,
  Ra_seq = 7,            # Different inner radius
  Rb_seq = 12,           # Different outer radius
  seed = 456
)[[1]]

# Create second SGWT object
SG2 <- initSGWT(pattern_2, x_col = "X", y_col = "Y", signals = "signal_1", 
                k = 12, J = 4)
SG2 <- runSpecGraph(SG2, verbose = FALSE)
SG2 <- runSGWT(SG2, verbose = FALSE)

# Calculate cross-object similarity
similarity_cross <- runSGCC(SG, SG2, return_parts = TRUE)

cat("\nCross-object Pattern Similarity:\n")
cat(sprintf("Overall similarity: %.4f\n", similarity_cross$S))
cat(sprintf("Low-frequency similarity: %.4f\n", similarity_cross$c_low))
cat(sprintf("Non-low-frequency similarity: %.4f\n", similarity_cross$c_nonlow))

# Visualize both patterns for comparison
p_comp1 <- ggplot(demo_pattern, aes(X, Y, fill = factor(signal_1))) +
  geom_tile() + scale_fill_manual(values = c("0" = "white", "1" = "#e31a1c")) +
  coord_fixed() + theme_void() + theme(legend.position = "none") +
  ggtitle("Pattern A (R_in=5, R_out=10)")

p_comp2 <- ggplot(pattern_2, aes(X, Y, fill = factor(signal_1))) +
  geom_tile() + scale_fill_manual(values = c("0" = "white", "1" = "#1f78b4")) +
  coord_fixed() + theme_void() + theme(legend.position = "none") +
  ggtitle("Pattern B (R_in=7, R_out=12)")

print(p_comp1 + p_comp2)
```

## Low-frequency Only Analysis

```{r low-frequency-analysis}
# Compare using only low-frequency components
similarity_low <- runSGCC("signal_1", "signal_2", SG = SG, low_only = TRUE, return_parts = TRUE)

cat("Low-frequency Only Similarity Analysis:\n")
cat(sprintf("Low-frequency similarity: %.4f\n", similarity_low$c_low))
cat(sprintf("Overall score (same as low-freq): %.4f\n", similarity_low$S))
cat("Note: Non-low-frequency components are ignored (c_nonlow = NA)\n")

# Compare with full analysis
cat("\nComparison:\n")
cat(sprintf("Full analysis similarity: %.4f\n", similarity_within$S))
cat(sprintf("Low-only similarity: %.4f\n", similarity_low$S))
cat(sprintf("Difference: %.4f\n", abs(similarity_within$S - similarity_low$S)))
```

## Multiple Signal Analysis

```{r multiple-signals}
# Analyze energy distribution for both signals
energy_signal1 <- sgwt_energy_analysis(SG, "signal_1")
energy_signal2 <- sgwt_energy_analysis(SG, "signal_2")

# Combine for comparison
energy_comparison <- rbind(energy_signal1, energy_signal2)

# Plot comparison
ggplot(energy_comparison, aes(x = scale, y = energy_ratio, fill = signal)) +
  geom_bar(stat = "identity", position = "dodge", alpha = 0.7) +
  geom_text(aes(label = paste0(round(energy_ratio * 100, 1), "%")), 
            position = position_dodge(width = 0.9), vjust = -0.5, size = 3) +
  scale_fill_viridis_d() +
  labs(title = "Energy Distribution Comparison: Signal 1 vs Signal 2",
       x = "Scale", y = "Energy Ratio", fill = "Signal") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# Advanced Workflow Features

## Custom Parameters

```{r custom-parameters}
# Demonstrate advanced parameter customization
SG_advanced <- initSGWT(
  data.in = demo_pattern,
  x_col = "X", y_col = "Y",
  signals = "signal_1",
  k = 15,                    # More neighbors for smoother graph
  J = 6,                     # More scales for finer analysis
  scaling_factor = 1.5,      # Closer scales
  kernel_type = "heat",      # Heat kernel
  laplacian_type = "randomwalk"  # Different Laplacian normalization
)

SG_advanced <- runSpecGraph(SG_advanced, verbose = FALSE)
SG_advanced <- runSGWT(SG_advanced, verbose = FALSE)

cat("Advanced Parameters Results:\n")
cat("Number of scales:", length(SG_advanced$Parameters$scales), "\n")
cat("Scales:", paste(round(SG_advanced$Parameters$scales, 4), collapse = ", "), "\n")
cat("Reconstruction error:", round(SG_advanced$Inverse$signal_1$reconstruction_error, 6), "\n")
```

## Performance Characteristics

```{r performance-summary}
# Summary of computational performance
cat("Performance Summary for Current Analysis:\n")
cat("Grid size: 40x40 =", 40^2, "points\n")
cat("SGWT scales: 4\n") 
cat("Neighbor parameter k: 12\n")
cat("Eigendecomposition: k_neighbor = 25 (fixed)\n")

# Compare different approaches
approaches <- data.frame(
  Approach = c("Standard", "High-resolution", "Fast"),
  k_neighbors = c(12, 20, 8),
  J_scales = c(4, 6, 3),
  Expected_Time = c("2-5 seconds", "5-10 seconds", "1-3 seconds"),
  Use_Case = c("General analysis", "Detailed patterns", "Quick screening")
)

print("Approach Comparison:")
print(approaches)
```

# Summary

## Key Takeaways

1. **New Object-Oriented Workflow**: Clear separation of initialization, graph building, analysis, and similarity computation
2. **Flexible Input**: Supports custom column naming for coordinates and signals  
3. **Multiple Kernels**: Choose from Mexican Hat, Meyer, or Heat kernel families
4. **Comprehensive Similarity**: Energy-normalized weighted similarity with detailed diagnostics
5. **Advanced Analysis**: Low-frequency only analysis, cross-object comparison, multiple signal support

## New Workflow Benefits

```r
# Complete workflow in 4 clear steps:
SG <- initSGWT(data, signals = c("signal1", "signal2"))  # 1. Initialize
SG <- runSpecGraph(SG)                                   # 2. Build graph  
SG <- runSGWT(SG)                                        # 3. Run SGWT
similarity <- runSGCC("signal1", "signal2", SG = SG)    # 4. Compare patterns
```

## Parameter Guidelines

- **Small datasets (<200 points)**: k=8-12, J=3-4
- **Medium datasets (200-1000 points)**: k=12-20, J=4-6  
- **Large datasets (>1000 points)**: k=15-25, J=5-8

## Next Steps

- Explore your own spatial datasets using the demonstrated workflow
- Experiment with different kernel types and parameters
- Use comprehensive similarity analysis for comparative studies
- Refer to function documentation for detailed parameter specifications

---

*BioGSP Package - Biological Graph Signal Processing for Spatial Data Analysis*