---
title: "SGWT Analysis with Simulation Patterns"
author: "BioGSP Package"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    theme: flatly
vignette: >
  %\VignetteIndexEntry{SGWT Analysis with Simulation Patterns}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      fig.width = 10, fig.height = 8)
```

# Introduction

This vignette demonstrates the use of Spectral Graph Wavelet Transform (SGWT) analysis using the BioGSP package with two types of simulated spatial patterns:

1. **Multiple Center Patterns**: Concentric circles with inner and outer rings at different scales
2. **Concentric Ring Patterns**: Dynamic ring patterns with moving outer boundaries

The package now supports flexible column naming, allowing you to use any column names for spatial coordinates (X, Y) and signals (signal_1, signal_2).

# Load Required Libraries

```{r load-libraries}
# Load required packages
library(ggplot2)
library(patchwork)
library(dplyr)
library(viridis)
library(Matrix)
library(igraph)
library(RANN)
library(RSpectra)
library(ggpubr)

# Load BioGSP functions directly
source('../R/simulation.R')
source('../R/sgwt_core.R')
source('../R/sgwt_main.R')
source('../R/utilities.R')
source('../R/visualization.R')

# Set random seed for reproducibility
set.seed(123)
```

# Part 1: Multiple Center Simulation

## Generate Multiple Center Patterns

First, let's generate spatial patterns with multiple circular centers at different scales.

```{r generate-multicenter}
# Define parameter sequences
Ra_seq <- seq(from = 10, to = 3, length.out = 4)   # Inner circle radii
Rb_seq <- seq(from = 15, to = 5, length.out = 4)   # Outer ring radii

# Generate simulation data
multicenter_data <- simulate_multiscale(
  grid_size = 50,
  n_centers = 3,
  Ra_seq = Ra_seq,
  Rb_seq = Rb_seq,
  seed = 123
)

# Display the structure of generated data
cat("Generated", length(multicenter_data), "different pattern combinations\n")
cat("Data structure for first pattern:\n")
str(multicenter_data[[1]])
```

## Visualize Multiple Center Patterns

```{r visualize-multicenter, fig.width=12, fig.height=10}
# Create visualization of all pattern combinations
multicenter_plot <- visualize_multiscale(
  sim_data = multicenter_data,
  Ra_seq = Ra_seq,
  Rb_seq = Rb_seq,
  bg_color = "grey",      
  signal1_color = "#16964a",    
  signal2_color = "#2958a8"
)

print(multicenter_plot)
```

## SGWT Analysis on Multiple Center Data

Let's perform SGWT analysis on one of the generated patterns.

```{r sgwt-multicenter}
# Select a specific pattern for analysis
selected_pattern <- multicenter_data[["simulated_Ra_3_Rb_8.33333333333333"]]

# Perform SGWT analysis on signal_1 (inner circles)
sgwt_result_signal1 <- SGWT(
  data.in = selected_pattern,
  x_col = "X",
  y_col = "Y", 
  signal = "signal_1",
  k = 15,
  J = 4,
  scaling_factor = 2,
  kernel_type = "mexican_hat",
  k_fold = 8
)

cat("SGWT Analysis Results for Signal 1 (Inner Circles):\n")
cat("Reconstruction RMSE:", sgwt_result_signal1$reconstruction_error, "\n")
cat("Number of scales:", length(sgwt_result_signal1$decomposition$scales), "\n")
cat("Scales:", paste(round(sgwt_result_signal1$decomposition$scales, 4), collapse = ", "), "\n")
```

## Visualize SGWT Decomposition Results

```{r plot-sgwt-multicenter, fig.width=12, fig.height=8}
# Plot SGWT decomposition results
sgwt_plots <- plot_sgwt_decomposition(
  sgwt_result = sgwt_result_signal1,
  data.in = selected_pattern,
  x_col = "X",
  y_col = "Y",
  plot_scales = 1:3,
  ncol = 3
)

print(sgwt_plots)
```

## Energy Analysis

```{r energy-analysis-multicenter}
# Analyze energy distribution across scales
energy_analysis <- sgwt_energy_analysis(sgwt_result_signal1)
print(energy_analysis)

# Create energy distribution plot
energy_plot <- ggplot(energy_analysis, aes(x = scale, y = energy_ratio)) +
  geom_bar(stat = "identity", fill = "steelblue", alpha = 0.7) +
  geom_text(aes(label = paste0(round(energy_ratio * 100, 1), "%")), 
            vjust = -0.5, size = 3) +
  labs(title = "Energy Distribution Across SGWT Scales",
       subtitle = "Multiple Center Pattern - Inner Circles",
       x = "Scale", y = "Energy Ratio") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(energy_plot)
```

# Part 2: Concentric Ring Simulation

## Generate Concentric Ring Patterns

Now let's generate concentric ring patterns with dynamic outer boundaries.

```{r generate-rings}
# Define radius sequence for inner circles
radius_seq <- seq(5, 15, by = 5)

# Generate concentric ring simulation data
ring_data <- simulate_ringpattern(
  grid_size = 60,
  radius_seq = radius_seq,
  n_movements = 6
)

# Display the structure of generated data
cat("Generated", length(ring_data), "different radius patterns\n")
cat("Data structure for first pattern:\n")
str(ring_data[[1]][1:10, ])  # Show first 10 rows
```

## Visualize Concentric Ring Patterns

```{r visualize-rings, fig.width=14, fig.height=12}
# Create visualization of ring patterns
ring_plot <- visualize_ringpattern(
  sim_data = ring_data,
  radius_seq = radius_seq,
  bg_color = "grey",      
  signal1_color = "#16964a",    
  signal2_color = "#2958a8"
)

print(ring_plot)
```

## SGWT Analysis on Ring Data

Let's analyze the dynamic ring patterns using SGWT.

```{r sgwt-rings}
# Select a specific radius and movement for analysis
selected_ring_data <- ring_data[["radius_10"]]
# Filter to a specific movement step
movement_3_data <- selected_ring_data[selected_ring_data$movement_step == 3, ]

# Perform SGWT analysis on signal_2 (dynamic rings)
sgwt_result_rings <- SGWT(
  data.in = movement_3_data,
  x_col = "X",
  y_col = "Y",
  signal = "signal_2",
  k = 12,
  J = 4,
  scaling_factor = 2,
  kernel_type = "meyer",
  k_fold = 8
)

cat("SGWT Analysis Results for Ring Pattern:\n")
cat("Reconstruction RMSE:", sgwt_result_rings$reconstruction_error, "\n")
cat("Number of scales:", length(sgwt_result_rings$decomposition$scales), "\n")
cat("Scales:", paste(round(sgwt_result_rings$decomposition$scales, 4), collapse = ", "), "\n")
```

## Visualize Ring SGWT Results

```{r plot-sgwt-rings, fig.width=12, fig.height=8}
# Plot SGWT decomposition for ring patterns
ring_sgwt_plots <- plot_sgwt_decomposition(
  sgwt_result = sgwt_result_rings,
  data.in = movement_3_data,
  x_col = "X",
  y_col = "Y",
  plot_scales = 1:3,
  ncol = 3
)

print(ring_sgwt_plots)
```

## Compare Different Kernel Types

Let's compare how different wavelet kernel types perform on the same data.

```{r compare-kernels, fig.width=12, fig.height=10}
# Test different kernel types
kernel_types <- c("mexican_hat", "meyer", "heat")
kernel_results <- list()

for (kernel in kernel_types) {
  result <- SGWT(
    data.in = movement_3_data,
    x_col = "X",
    y_col = "Y",
    signal = "signal_2",
    k = 12,
    J = 3,
    scaling_factor = 2,
    kernel_type = kernel,
    k_fold = 8
  )
  kernel_results[[kernel]] <- result
}

# Compare reconstruction errors
comparison_df <- data.frame(
  Kernel = kernel_types,
  RMSE = sapply(kernel_results, function(x) x$reconstruction_error),
  stringsAsFactors = FALSE
)

print("Reconstruction Error Comparison:")
print(comparison_df)

# Plot comparison
comparison_plot <- ggplot(comparison_df, aes(x = Kernel, y = RMSE, fill = Kernel)) +
  geom_bar(stat = "identity", alpha = 0.7) +
  geom_text(aes(label = round(RMSE, 6)), vjust = -0.5) +
  scale_fill_viridis_d() +
  labs(title = "SGWT Reconstruction Error by Kernel Type",
       subtitle = "Concentric Ring Pattern Analysis",
       x = "Kernel Type", y = "RMSE") +
  theme_minimal()

print(comparison_plot)
```

# Part 3: Cross-Signal Analysis

## Graph Cross-Correlation (GCC) Analysis

Let's analyze the relationship between the two signals using Graph Cross-Correlation.

```{r gcc-analysis}
# Use the multiple center data with both signals
# First, let's see what keys are available
cat("Available pattern keys:\n")
print(names(multicenter_data))

# Use the first available pattern
pattern_data <- multicenter_data[[1]]

# Calculate eigendecomposition for GCC analysis
eigen_result <- Cal_Eigen(
  data.in = pattern_data,
  x_col = "X",
  y_col = "Y",
  k = 15,
  k_fold = 10,
  sensitivity = 2
)

knee_point <- eigen_result[[1]]
eigenvectors <- eigen_result[[2]]
eigenvalues <- eigen_result[[3]]

# Calculate Graph Cross-Correlation between the two signals
# Using the new comprehensive similarity function
gcc_value <- sgwt_similarity("signal_1", "signal_2", 
                            data.in = pattern_data, 
                            k = 15, J = 4)

cat("Graph Cross-Correlation between Inner Circles and Outer Rings:\n")
cat("SGWT Similarity Value:", gcc_value, "\n")
cat("Knee point (low-frequency cutoff):", knee_point, "\n")

# For comparison, show the old method (deprecated)
cat("\nFor comparison, old Cal_GCC method (deprecated):\n")
old_gcc_value <- Cal_GCC(
  data.in = pattern_data,
  knee = knee_point,
  signal1 = "signal_1",
  signal2 = "signal_2",
  eigenvector = eigenvectors
)
cat("Old GCC Value:", old_gcc_value, "\n")
```

## Visualize Both Signals

```{r visualize-both-signals, fig.width=12, fig.height=5}
# Create plots for both signals
p1 <- ggplot(pattern_data, aes(X, Y, fill = factor(signal_1))) +
  geom_tile() +
  scale_fill_manual(values = c("0" = "white", "1" = "red"), 
                    name = "Signal 1", labels = c("Background", "Inner Circle")) +
  coord_fixed() +
  theme_void() +
  ggtitle("Signal 1: Inner Circles")

p2 <- ggplot(pattern_data, aes(X, Y, fill = factor(signal_2))) +
  geom_tile() +
  scale_fill_manual(values = c("0" = "white", "1" = "blue"), 
                    name = "Signal 2", labels = c("Background", "Outer Ring")) +
  coord_fixed() +
  theme_void() +
  ggtitle("Signal 2: Outer Rings")

combined_signals <- p1 + p2
print(combined_signals)
```

# Part 4: Advanced Analysis

## Multi-Scale Energy Analysis

Let's analyze how energy distribution changes across different pattern scales.

```{r multiscale-energy}
# Analyze multiple patterns with different scales
energy_results <- list()

for (i in 1:3) {
  pattern_name <- names(multicenter_data)[i]
  pattern_data <- multicenter_data[[i]]
  
  # SGWT analysis
  sgwt_result <- SGWT(
    data.in = pattern_data,
    x_col = "X", y_col = "Y",
    signal = "signal_1",
    k = 12, J = 4,
    scaling_factor = 2,
    k_fold = 8
  )
  
  # Energy analysis
  energy <- sgwt_energy_analysis(sgwt_result)
  energy$pattern <- pattern_name
  energy_results[[i]] <- energy
}

# Combine results
all_energy <- do.call(rbind, energy_results)

# Plot energy distribution across patterns
energy_comparison <- ggplot(all_energy, aes(x = scale, y = energy_ratio, fill = pattern)) +
  geom_bar(stat = "identity", position = "dodge", alpha = 0.7) +
  scale_fill_viridis_d() +
  labs(title = "Energy Distribution Comparison Across Different Patterns",
       x = "Scale", y = "Energy Ratio", fill = "Pattern") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom")

print(energy_comparison)
```

## Kernel Visualization

Finally, let's visualize the different kernel families used in SGWT.

```{r kernel-visualization, fig.width=10, fig.height=6}
# Compare kernel families
kernel_comparison <- compare_kernel_families(
  x_range = c(0, 3),
  scale_param = 1,
  plot_results = TRUE
)

# The plot is generated automatically by the function
cat("Kernel comparison data structure:\n")
str(kernel_comparison[1:5, ])
```

## Comprehensive Signal Similarity Analysis

Let's demonstrate the new unified signal similarity functions that provide more comprehensive analysis than the old Cal_GCC approach:

```{r comprehensive-similarity}
# Demonstrate the new sgwt_similarity function with different input methods
cat("=== Comprehensive Signal Similarity Analysis ===\n")

# Method 1: Direct signal comparison (most convenient)
sim_direct <- sgwt_similarity("signal_1", "signal_2", 
                             data.in = selected_pattern, 
                             k = 15, J = 4, return_parts = TRUE)

cat("Method 1 - Direct signal comparison:\n")
cat(sprintf("Overall similarity: %.4f\n", sim_direct$S))
cat(sprintf("Low-frequency similarity: %.4f\n", sim_direct$c_low))
cat(sprintf("Non-low-frequency similarity: %.4f\n", sim_direct$c_nonlow))
cat(sprintf("Energy weights - Low: %.3f, Non-low: %.3f\n", sim_direct$w_low, sim_direct$w_NL))

# Method 2: Pre-computed SGWT results (for advanced users)
sgwt_sig1 <- SGWT(selected_pattern, x_col = "X", y_col = "Y", signal = "signal_1", k = 15, J = 4)
sgwt_sig2 <- SGWT(selected_pattern, x_col = "X", y_col = "Y", signal = "signal_2", k = 15, J = 4)

sim_precomputed <- sgwt_similarity(sgwt_sig1, sgwt_sig2, return_parts = TRUE)
cat("\nMethod 2 - Pre-computed SGWT results:\n")
cat(sprintf("Overall similarity: %.4f\n", sim_precomputed$S))

# Method 3: Low-frequency only analysis
sim_low_only <- sgwt_similarity("signal_1", "signal_2", 
                               data.in = selected_pattern,
                               k = 15, J = 4, low_only = TRUE)
cat("\nMethod 3 - Low-frequency only:\n")
cat(sprintf("Low-frequency similarity: %.4f\n", sim_low_only))

# Comparison with old Cal_GCC method
pattern_with_eigen <- selected_pattern
eigen_result_comp <- Cal_Eigen(pattern_with_eigen, x_col = "X", y_col = "Y", k = 15, k_fold = 8, sensitivity = 2)
old_gcc <- Cal_GCC(pattern_with_eigen, knee = eigen_result_comp[[1]], 
                   signal1 = "signal_1", signal2 = "signal_2", 
                   eigenvector = eigen_result_comp[[2]])

cat(sprintf("\nComparison with old Cal_GCC: %.4f\n", old_gcc))
cat(sprintf("New comprehensive method: %.4f\n", sim_direct$S))
cat(sprintf("Improvement in analysis depth: %s\n", 
            ifelse(abs(sim_direct$S - old_gcc) > 0.01, "Significant", "Comparable")))
```

## Energy-Normalized Weighted Similarity

Let's test the low-level energy-normalized weighted similarity function that compares two SGWT results:

```{r weighted-similarity-test}
# Test the weighted similarity function between the two patterns
cat("Testing sgwt_weighted_similarity function...\n")

# First, let's create two SGWT results on the same spatial grid for proper comparison
# Use the same pattern data but analyze different signals

# Check dimensions first
cat("Checking dimensions:\n")
cat(sprintf("Multicenter data dimensions: %d x %d\n", nrow(selected_pattern), ncol(selected_pattern)))
cat(sprintf("Ring data dimensions: %d x %d\n", nrow(movement_3_data), ncol(movement_3_data)))

# Create two SGWT results on the same spatial grid (selected_pattern) for both signals
sgwt_signal1_test <- SGWT(
  data.in = selected_pattern,
  x_col = "X", y_col = "Y", 
  signal = "signal_1",
  k = 15, J = 4, scaling_factor = 2,
  kernel_type = "mexican_hat", k_fold = 8
)

sgwt_signal2_test <- SGWT(
  data.in = selected_pattern,
  x_col = "X", y_col = "Y",
  signal = "signal_2", 
  k = 15, J = 4, scaling_factor = 2,
  kernel_type = "mexican_hat", k_fold = 8
)

# Full similarity analysis (both low and non-low frequencies)
full_similarity <- sgwt_weighted_similarity(sgwt_signal1_test, sgwt_signal2_test, 
                                           validate = TRUE, return_parts = TRUE)

cat("Full Weighted Similarity Results:\n")
cat(sprintf("Low-frequency cosine similarity: %.4f\n", full_similarity$c_low))
cat(sprintf("Non-low-frequency cosine similarity: %.4f\n", full_similarity$c_nonlow))
cat(sprintf("Low-frequency weight: %.4f\n", full_similarity$w_low))
cat(sprintf("Non-low-frequency weight: %.4f\n", full_similarity$w_NL))
cat(sprintf("Overall weighted similarity: %.4f\n", full_similarity$S))

# Energy diagnostics
cat("\nEnergy Analysis:\n")
cat(sprintf("Signal 1 - Low-freq energy: %.4f, Non-low energy: %.4f\n", 
            full_similarity$E_low_a, full_similarity$E_NL_a))
cat(sprintf("Signal 2 - Low-freq energy: %.4f, Non-low energy: %.4f\n", 
            full_similarity$E_low_b, full_similarity$E_NL_b))

# Low-frequency only similarity
low_only_similarity <- sgwt_weighted_similarity(sgwt_signal1_test, sgwt_signal2_test, 
                                               low_only = TRUE, return_parts = TRUE)

cat(sprintf("\nLow-frequency only similarity: %.4f\n", low_only_similarity$S))

# Test with just the scalar output
scalar_similarity <- sgwt_weighted_similarity(sgwt_signal1_test, sgwt_signal2_test, 
                                             return_parts = FALSE)
cat(sprintf("Scalar similarity output: %.4f\n", scalar_similarity))

# Test with decomposition objects directly
decomp_similarity <- sgwt_weighted_similarity(sgwt_signal1_test$decomposition, 
                                             sgwt_signal2_test$decomposition, 
                                             return_parts = FALSE)
cat(sprintf("Direct decomposition similarity: %.4f\n", decomp_similarity))
```

```{r similarity-comparison}
# Compare similarities between different pattern combinations
cat("Comparing similarities between different patterns:\n")

# Self-similarity (should be close to 1)
self_sim_signal1 <- sgwt_weighted_similarity(sgwt_signal1_test, sgwt_signal1_test, return_parts = FALSE)
self_sim_signal2 <- sgwt_weighted_similarity(sgwt_signal2_test, sgwt_signal2_test, return_parts = FALSE)

cat(sprintf("Signal 1 self-similarity: %.6f\n", self_sim_signal1))
cat(sprintf("Signal 2 self-similarity: %.6f\n", self_sim_signal2))

# Cross-similarity between different signals on same spatial grid
cross_sim <- sgwt_weighted_similarity(sgwt_signal1_test, sgwt_signal2_test, return_parts = FALSE)
cat(sprintf("Cross-signal similarity (signal1 vs signal2): %.4f\n", cross_sim))

# Test with different kernel types from the kernel comparison section
# Compare Mexican Hat vs Meyer kernels on the same data
if (exists("kernel_results") && length(kernel_results) >= 2) {
  mexican_hat_result <- kernel_results[["mexican_hat"]]
  meyer_result <- kernel_results[["meyer"]]
  
  kernel_cross_sim <- sgwt_weighted_similarity(mexican_hat_result, meyer_result, 
                                              return_parts = FALSE)
  cat(sprintf("Different kernel similarity (Mexican Hat vs Meyer): %.4f\n", kernel_cross_sim))
}
```

```{r similarity-validation}
# Test validation features
cat("Testing validation features:\n")

# This should work fine - validation with compatible SGWT results
try({
  valid_result <- sgwt_weighted_similarity(sgwt_signal1_test, sgwt_signal2_test, 
                                          validate = TRUE, return_parts = FALSE)
  cat("Validation passed successfully\n")
})

# Test with validation disabled
no_validate_result <- sgwt_weighted_similarity(sgwt_signal1_test, sgwt_signal2_test, 
                                              validate = FALSE, return_parts = FALSE)
cat(sprintf("No validation result: %.4f\n", no_validate_result))

# Test error handling with mismatched inputs
# Try comparing SGWT results from different spatial grids (should give warning)
try({
  mismatch_result <- sgwt_weighted_similarity(sgwt_result_signal1, sgwt_result_rings, 
                                             validate = TRUE, return_parts = FALSE)
  cat("Unexpected: mismatched inputs passed validation\n")
}, silent = TRUE)

cat("Weighted similarity function implementation and testing complete!\n")
```

# Summary

This vignette demonstrated:

1. **Simulation Pattern Generation**: Created two types of spatial patterns with flexible column naming support
2. **SGWT Analysis**: Applied spectral graph wavelet transforms to analyze multi-scale spatial structures
3. **Flexible Column Support**: Used custom column names (X, Y, signal_1, signal_2) throughout the analysis
4. **Kernel Comparison**: Evaluated different wavelet kernel types (Mexican Hat, Meyer, Heat)
5. **Energy Analysis**: Analyzed energy distribution across different scales and patterns
6. **Cross-Signal Analysis**: Used Graph Cross-Correlation to analyze relationships between signals
7. ****NEW** Weighted Similarity**: Tested energy-normalized weighted similarity between SGWT results

## Key Features Demonstrated

- **Flexible Input Format**: Support for any column names for coordinates and signals
- **Multiple Kernel Types**: Mexican Hat, Meyer, and Heat kernel families
- **Comprehensive Visualization**: Built-in plotting functions for patterns and SGWT results
- **Energy Analysis**: Tools for understanding signal energy distribution across scales
- **Graph Cross-Correlation**: Methods for analyzing relationships between multiple signals
- ****NEW** Energy-Normalized Similarity**: Advanced similarity measures between SGWT decompositions

The BioGSP package provides a comprehensive toolkit for spectral graph wavelet analysis of spatial data with flexible input formats, extensive visualization capabilities, and advanced similarity analysis tools.
